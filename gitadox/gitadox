#!/usr/bin/env node

async function aiCreateBranch() {
  // Get current status or context for branch naming
  const status = run('git status');
  const prompt = `Suggest a short, valid git branch name (kebab-case, no spaces or special characters) based on this git status/context. Only output the branch name, nothing else.\n${status}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let branchName = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) branchName += obj.response;
    } catch {}
  }
  branchName = branchName.replace(/[^a-zA-Z0-9\-]/g, '').replace(/\s+/g, '-').toLowerCase().trim();
  if (!branchName) {
    console.log(chalk.red('AI did not provide a valid branch name.'));
    return;
  }
  // Show the suggested branch name and create/switch to it
  console.log(boxen(chalk.green(`AI suggested branch name: ${branchName}`), { padding: 1, borderColor: 'green' }));
  const result = run(`git checkout -b ${branchName}`);
  console.log(boxen(chalk.green(`Created and switched to new branch: ${branchName}`), { padding: 1, borderColor: 'green' }));
  console.log(result);
}

// Usage: ./gitadox or node gitadox
import inquirer from 'inquirer';
import chalk from 'chalk';
import boxen from 'boxen';
import fetch from 'node-fetch';
import { execSync, exec } from 'child_process';

const OLLAMA_URL = 'http://localhost:11434/api/generate';
const OLLAMA_MODEL = 'llama3.1:8b';

function run(cmd, opts = {}) {
  try {
    return execSync(cmd, { stdio: 'pipe', encoding: 'utf8', ...opts }).trim();
  } catch (e) {
    return e.stdout ? e.stdout.toString() : e.message;
  }
}

async function getAICommitMessage(diff) {
  const prompt = `Analyze the following git diff and generate a meaningful, context-aware commit message that accurately summarizes the changes. The message must follow the Conventional Commits specification (e.g., feat:, fix:, chore:, refactor:, etc.), and should be clear and specific about what was changed. Only output the commit message itself, no explanations or formatting.\n\n${diff}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  // Ollama streams JSON lines, each with a 'response' field. Extract and join them.
  let commitMsg = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) commitMsg += obj.response;
    } catch {}
  }
  // Clean up and return the message
  commitMsg = commitMsg.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  // Optionally, only take the first line for a concise commit
  if (commitMsg.includes('.')) commitMsg = commitMsg.split('.')[0].trim();
  return commitMsg || 'chore: update';
}

async function aiStatus() {
  const status = run('git status');
  const prompt = `Summarize this git status output in plain English for a developer:\n${status}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  console.log(boxen(chalk.cyan('AI Status Summary:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || status);
}

async function aiLog() {
  const log = run('git log --oneline --decorate --graph -20');
  const prompt = `Summarize this git log for a developer, highlighting key changes and branches. Format the summary in clear, short paragraphs or bullet points for easy reading.\n${log}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  // Try to preserve line breaks and bullet points for readability
  summary = summary.replace(/\n{2,}/g, '\n').replace(/\n/g, '\n').replace(/\s+\n/g, '\n').trim();
  console.log(boxen(chalk.cyan('AI Log Summary:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || log);
}

async function aiBranch() {
  const branchesRaw = run('git branch -a');
  // Collect all branches, local and remote, and remove duplicates
  let branches = branchesRaw
    .split('\n')
    .map(b => b.replace('*', '').trim())
    .filter(b => b && !b.includes('->'));
  // Remove duplicate remote branches that match local ones
  const uniqueBranches = Array.from(new Set(branches));
  const { branch } = await inquirer.prompt([
    {
      type: 'list',
      name: 'branch',
      message: chalk.cyan('Select a branch to switch to:'),
      choices: uniqueBranches,
      pageSize: 15
    }
  ]);
  const result = run(`git checkout ${branch}`);
  console.log(boxen(chalk.green(`Switched to branch: ${branch}`), { padding: 1, borderColor: 'green' }));
  console.log(result);
}

async function aiMerge() {
  const { branch } = await inquirer.prompt([
    { type: 'input', name: 'branch', message: 'Enter the branch to merge into current:' }
  ]);
  const mergeRes = run(`git merge ${branch}`);
  const prompt = `Explain the result of this git merge command for a developer:\n${mergeRes}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  console.log(boxen(chalk.cyan('AI Merge Summary:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || mergeRes);
}

async function aiPush() {
  const pushRes = run('git push');
  console.log(pushRes);
}

async function aiPull() {
  const pullRes = run('git pull');
  console.log(pullRes);
}

async function aiHelp() {
  const helpText = `Commands available:\n- AI Save (add, commit, pull, push)\n- AI Status\n- AI Log\n- AI Branch\n- AI Merge\n- Push\n- Pull\n- Exit`;
  const prompt = `Format this help text for a developer-friendly CLI:\n${helpText}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  console.log(boxen(chalk.cyan('AI Help:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || helpText);
}

async function save() {
  // Always stage all changes (including unstaged and deletions)
  run('git add -A');
  run('git add gitadox/gitadox');
  const status = run('git status --porcelain');
  if (status) {
    const diff = run('git diff --cached');
    const commitMsg = await getAICommitMessage(diff);
    run(`git commit -m "${commitMsg.replace(/"/g, '\"')}"`);
    const pullRes = run('git pull --rebase');
    if (/error|conflict/i.test(pullRes)) {
      console.log(chalk.red('Pull failed or merge conflict! Resolve and try again.'));
      console.log(pullRes);
      return;
    }
    const pushRes = run('git push');
    if (/error|failed/i.test(pushRes)) {
      console.log(chalk.red('Push failed!'));
      console.log(pushRes);
      return;
    }
    console.log(boxen(chalk.green('All changes staged, committed, pulled, and pushed!'), { padding: 1, borderColor: 'green' }));
  } else {
    console.log(chalk.yellow('No changes to save.'));
  }

  // Also save in parent directory if it is a git repo and not the same as current
  const path = process.cwd();
  const pathModule = await import('path');
  const parent = pathModule.resolve(path, '..');
  if (parent !== path) {
    try {
      const fs = await import('fs');
      if (fs.existsSync(pathModule.join(parent, '.git'))) {
        console.log(chalk.cyan(`\nRunning save in parent repo: ${parent}`));
        const child_process = await import('child_process');
        const result = child_process.spawnSync(process.argv[0], [process.argv[1], 'save'], { cwd: parent, stdio: 'inherit' });
        if (result.error) {
          console.log(chalk.red('Failed to run save in parent repo:'), result.error);
        }
      }
    } catch (e) {
      console.log(chalk.red('Error checking or running save in parent repo:'), e);
    }
  }
}

async function main() {
  const choices = [
    { name: 'AI Save (add, commit, pull, push)', value: 'save' },
    { name: 'AI Status', value: 'status' },
    { name: 'AI Log', value: 'log' },
    { name: 'AI Branch', value: 'branch' },
    { name: 'AI Create Branch (AI-named)', value: 'ai-create-branch' },
    { name: 'AI Merge', value: 'merge' },
    { name: 'Push', value: 'push' },
    { name: 'Pull', value: 'pull' },
    { name: 'AI Help', value: 'help' },
    { name: 'Exit', value: 'exit' }
  ];
  const { cmd } = await inquirer.prompt([
    {
      type: 'list',
      name: 'cmd',
      message: chalk.cyan('What do you want to do?'),
      choices,
      pageSize: 10
    }
  ]);
  if (cmd === 'save') {
    await save();
  } else if (cmd === 'status') {
    await aiStatus();
  } else if (cmd === 'log') {
    await aiLog();
  } else if (cmd === 'branch') {
    await aiBranch();
  } else if (cmd === 'ai-create-branch') {
    await aiCreateBranch();
  } else if (cmd === 'merge') {
    await aiMerge();
  } else if (cmd === 'push') {
    await aiPush();
  } else if (cmd === 'pull') {
    await aiPull();
  } else if (cmd === 'help') {
    await aiHelp();
  } else {
    process.exit(0);
  }
  process.exit(0);
}

if (process.argv[2] === 'save') {
  await save();
} else {
  await main();
}
