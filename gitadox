#!/usr/bin/env node

import * as github from './github.js';


// Undo/Redo state
let lastAction = null;
let redoAction = null;

async function undoLastAction() {
  if (!lastAction) {
    console.log('Nothing to undo.');
    return;
  }
  if (lastAction.type === 'commit') {
    // Undo last commit (soft reset)
    run('git reset --soft HEAD~1');
    console.log('Last commit undone.');
    redoAction = lastAction;
    lastAction = null;
  } else if (lastAction.type === 'branch-switch') {
    // Switch back to previous branch
    run(`git checkout ${lastAction.prevBranch}`);
    console.log(`Switched back to branch: ${lastAction.prevBranch}`);
    redoAction = lastAction;
    lastAction = null;
  } else {
    console.log('Nothing to undo.');
  }
}

async function redoLastAction() {
  if (!redoAction) {
    console.log('Nothing to redo.');
    return;
  }
  if (redoAction.type === 'commit') {
    // Redo commit (not possible to fully restore, so just notify)
    console.log('Redo for commit is not supported. Please recommit manually.');
    redoAction = null;
  } else if (redoAction.type === 'branch-switch') {
    // Switch again to the branch
    run(`git checkout ${redoAction.newBranch}`);
    console.log(`Switched again to branch: ${redoAction.newBranch}`);
    redoAction = null;
  } else {
    console.log('Nothing to redo.');
  }
}
async function aiExplainAnything() {
  const { explainInput } = await inquirer.prompt([
    { type: 'input', name: 'explainInput', message: chalk.cyan('Paste a git command or error to explain:') }
  ]);
  if (!explainInput || !explainInput.trim()) {
    console.log(chalk.yellow('No input provided.'));
    return;
  }
  const prompt = `You are an expert git assistant. Explain the following git command or error message in clear, plain English, and provide actionable advice if relevant.\n\nINPUT:\n${explainInput}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let answer = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) answer += obj.response;
    } catch {}
  }
  answer = answer.replace(/\n{2,}/g, '\n').trim();
  console.log(boxen(chalk.cyan('AI Explanation:'), {padding: 1, borderColor: 'cyan'}));
  console.log(answer);
}
async function aiNaturalLanguageCommand() {
  const { nlcmd } = await inquirer.prompt([
    { type: 'input', name: 'nlcmd', message: chalk.cyan('Describe what you want to do (in plain English):') }
  ]);
  if (!nlcmd || !nlcmd.trim()) {
    console.log(chalk.yellow('No command entered.'));
    return;
  }
  const prompt = `You are an expert git CLI assistant. The user typed: "${nlcmd}".\n\n1. Suggest the exact git command(s) to accomplish this.\n2. Briefly explain what each command does.\n3. If the request is ambiguous, ask for clarification.\n\nFormat:\nCOMMAND: <git command>\nEXPLANATION: <explanation>\n`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let answer = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) answer += obj.response;
    } catch {}
  }
  answer = answer.replace(/\n{2,}/g, '\n').trim();
  console.log(boxen(chalk.cyan('AI Command Suggestion:'), {padding: 1, borderColor: 'cyan'}));
  console.log(answer);
}
async function aiConflictResolution() {
  // Interactive AI-powered conflict resolution
  const conflictedFiles = run('git diff --name-only --diff-filter=U')
    .split('\n')
    .map(f => f.trim())
    .filter(Boolean);
  if (!conflictedFiles.length) {
    console.log(chalk.green('No merge conflicts detected.'));
    return;
  }
  for (const file of conflictedFiles) {
    console.log(boxen(chalk.yellow(`Resolving conflicts in: ${file}`), {padding: 1, borderColor: 'yellow'}));
    const content = run(`cat "${file}"`);
    // Find all conflict hunks in the file
    const hunks = [];
    let lines = content.split('\n');
    let hunk = null;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].startsWith('<<<<<<<')) {
        hunk = { start: i, lines: [lines[i]] };
      } else if (hunk && lines[i].startsWith('=======')) {
        hunk.lines.push(lines[i]);
      } else if (hunk && lines[i].startsWith('>>>>>>>')) {
        hunk.lines.push(lines[i]);
        hunk.end = i;
        hunks.push(hunk);
        hunk = null;
      } else if (hunk) {
        hunk.lines.push(lines[i]);
      }
    }
    for (const h of hunks) {
      const hunkText = h.lines.join('\n');
      console.log(boxen(chalk.cyan('Conflict hunk:'), {padding: 1, borderColor: 'cyan'}));
      console.log(hunkText);
      const { action } = await inquirer.prompt([
        {
          type: 'list',
          name: 'action',
          message: 'How do you want to resolve this hunk?',
          choices: [
            { name: 'Accept current/ours', value: 'ours' },
            { name: 'Accept incoming/theirs', value: 'theirs' },
            { name: 'Ask AI for a suggestion', value: 'ai' },
            { name: 'Edit manually', value: 'edit' },
            { name: 'Skip for now', value: 'skip' }
          ]
        }
      ]);
      let replacement = null;
      if (action === 'ours') {
        // Take lines between <<<<<<< and =======
        replacement = h.lines.slice(1, h.lines.findIndex(l => l.startsWith('=======')));
      } else if (action === 'theirs') {
        // Take lines between ======= and >>>>>>>
        const eqIdx = h.lines.findIndex(l => l.startsWith('======='));
        replacement = h.lines.slice(eqIdx + 1, h.lines.length - 1);
      } else if (action === 'ai') {
        // Ask AI for a suggestion
        const aiPrompt = `You are an expert developer. Given the following git merge conflict hunk, suggest the best resolution and output only the resolved code.\n\n${hunkText}`;
        const aiRes = await fetch(OLLAMA_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ model: OLLAMA_MODEL, prompt: aiPrompt })
        });
        const text = await aiRes.text();
        let suggestion = '';
        for (const line of text.split(/\r?\n/)) {
          try {
            if (!line.trim()) continue;
            const obj = JSON.parse(line);
            if (obj.response) suggestion += obj.response;
          } catch {}
        }
        suggestion = suggestion.replace(/\n{2,}/g, '\n').trim();
        console.log(boxen(chalk.green('AI Suggestion:'), {padding: 1, borderColor: 'green'}));
        console.log(suggestion);
        const { useAI } = await inquirer.prompt([
          { type: 'confirm', name: 'useAI', message: 'Use this AI suggestion?', default: true }
        ]);
        if (useAI) replacement = suggestion.split('\n');
      } else if (action === 'edit') {
        const { manual } = await inquirer.prompt([
          { type: 'editor', name: 'manual', message: 'Edit the resolved code:' }
        ]);
        replacement = manual.split('\n');
      }
      if (replacement) {
        // Replace the hunk in lines
        lines = [
          ...lines.slice(0, h.start),
          ...replacement,
          ...lines.slice(h.end + 1)
        ];
        // Update hunk indices for subsequent hunks
        const diff = replacement.length - (h.end - h.start + 1);
        for (const later of hunks) {
          if (later.start > h.start) {
            later.start += diff;
            later.end += diff;
          }
        }
      }
    }
    // Write resolved file
    const fs = await import('fs');
    fs.writeFileSync(file, lines.join('\n'));
    console.log(chalk.green(`Conflicts resolved in ${file}.`));
  }
  console.log(chalk.green('All conflicts processed. You may now add and commit the resolved files.'));
}
async function aiExplainDiff() {
  const diff = run('git diff');
  if (!diff) {
    console.log(chalk.yellow('No changes to explain.'));
    return;
  }
  const prompt = `Explain the following git diff in plain English for a developer. Summarize what was changed, which files were affected, and the overall impact.\n${diff}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  console.log(boxen(chalk.cyan('AI Diff Explanation:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || diff);
}


async function aiCreateBranch() {
  // Get current status or context for branch naming
  const status = run('git status');
  const prompt = `Suggest a short, valid git branch name (kebab-case, no spaces or special characters) based on this git status/context. Only output the branch name, nothing else.\n${status}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let branchName = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) branchName += obj.response;
    } catch {}
  }
  branchName = branchName.replace(/[^a-zA-Z0-9\-]/g, '').replace(/\s+/g, '-').toLowerCase().trim();
  if (!branchName) {
    console.log(chalk.red('AI did not provide a valid branch name.'));
    return;
  }
  // Show the suggested branch name and create/switch to it
  console.log(boxen(chalk.green(`AI suggested branch name: ${branchName}`), { padding: 1, borderColor: 'green' }));
  const result = run(`git checkout -b ${branchName}`);
  console.log(boxen(chalk.green(`Created and switched to new branch: ${branchName}`), { padding: 1, borderColor: 'green' }));
  console.log(result);
}

// Usage: ./gitadox or node gitadox
import inquirer from 'inquirer';
import path from 'path';
// Register custom no-wrap list prompt
const NoWrapListPromptModule = await import('./noWrapListPrompt.js');
const NoWrapListPrompt = NoWrapListPromptModule.default || NoWrapListPromptModule;
inquirer.registerPrompt('no-wrap-list', NoWrapListPrompt);
import chalk from 'chalk';
import boxen from 'boxen';
import fetch from 'node-fetch';
import { execSync, exec } from 'child_process';

const OLLAMA_URL = 'http://localhost:11434/api/generate';
const OLLAMA_MODEL = 'llama3.1:8b';

function run(cmd, opts = {}) {
  try {
    return execSync(cmd, { stdio: 'pipe', encoding: 'utf8', ...opts }).trim();
  } catch (e) {
    return e.stdout ? e.stdout.toString() : e.message;
  }
}

async function getAICommitMessage(diff) {
  const prompt = `Analyze the following git diff and generate a meaningful, context-aware commit message that accurately summarizes the changes. The message must follow the Conventional Commits specification (e.g., feat:, fix:, chore:, refactor:, etc.), and should be clear and specific about what was changed. Only output the commit message itself, no explanations or formatting.\n\n${diff}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  // Ollama streams JSON lines, each with a 'response' field. Extract and join them.
  let commitMsg = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) commitMsg += obj.response;
    } catch {}
  }
  // Clean up and return the message
  commitMsg = commitMsg.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  // Optionally, only take the first line for a concise commit
  if (commitMsg.includes('.')) commitMsg = commitMsg.split('.')[0].trim();
  return commitMsg || 'chore: update';
}

async function aiStatus() {
  const status = run('git status');
  const prompt = `Summarize this git status output in plain English for a developer:\n${status}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  console.log(boxen(chalk.cyan('AI Status Summary:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || status);
}

async function aiLog() {
  const log = run('git log --oneline --decorate --graph -20');
  const prompt = `Summarize this git log for a developer, highlighting key changes and branches. Format the summary in clear, short paragraphs or bullet points for easy reading.\n${log}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  // Try to preserve line breaks and bullet points for readability
  summary = summary.replace(/\n{2,}/g, '\n').replace(/\n/g, '\n').replace(/\s+\n/g, '\n').trim();
  console.log(boxen(chalk.cyan('AI Log Summary:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || log);
}

async function aiBranch() {
  const branchesRaw = run('git branch -a');
  // Collect all branches, local and remote, and remove duplicates
  let branches = branchesRaw
    .split('\n')
    .map(b => b.replace('*', '').trim())
    .filter(b => b && !b.includes('->'));
  // Remove duplicate remote branches that match local ones
  const uniqueBranches = Array.from(new Set(branches));
  const { branch } = await inquirer.prompt([
    {
      type: 'list',
      name: 'branch',
      message: chalk.cyan('Select a branch to switch to:'),
      choices: uniqueBranches,
      pageSize: 15
    }
  ]);
  // Track undo for branch switch
  const currentBranch = run('git rev-parse --abbrev-ref HEAD');
  const result = run(`git checkout ${branch}`);
  lastAction = { type: 'branch-switch', prevBranch: currentBranch, newBranch: branch };
  redoAction = null;
  console.log(boxen(chalk.green(`Switched to branch: ${branch}`), { padding: 1, borderColor: 'green' }));
  console.log(result);
}

async function aiMerge() {
  const { branch } = await inquirer.prompt([
    { type: 'input', name: 'branch', message: 'Enter the branch to merge into current:' }
  ]);
  const mergeRes = run(`git merge ${branch}`);
  const prompt = `Explain the result of this git merge command for a developer:\n${mergeRes}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  console.log(boxen(chalk.cyan('AI Merge Summary:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || mergeRes);
}

async function aiPush() {
  const pushRes = run('git push');
  console.log(pushRes);
}

async function aiPull() {
  const pullRes = run('git pull');
  console.log(pullRes);
}

async function help() {
  const helpText = `Commands available:\n\n- Save (add, commit, pull, push): Stage, commit, pull, and push changes with AI commit message\n- Status: Show git status\n- Log: Show git log\n- Branch: List branches\n- Create Branch (AI-named): Create a new branch with an AI-generated name\n- Merge: Merge branches\n- Push: git push\n- Pull: git pull\n- Help: Show this help\n- Exit: Exit the CLI`;
  console.log(boxen(chalk.cyan('Help'), {padding: 1, borderColor: 'cyan'}));
  console.log(helpText);
}

async function save() {
  // Always stage all changes (including unstaged and deletions)
  run('git add -A');
  run('git add gitadox/gitadox');
  const status = run('git status --porcelain');
  if (status) {
    const diff = run('git diff --cached');
    const commitMsg = await getAICommitMessage(diff);
    run(`git commit -m "${commitMsg.replace(/"/g, '\"')}"`);
    // Track undo for commit
    lastAction = { type: 'commit' };
    redoAction = null;
    const pullRes = run('git pull --rebase');
    if (/error|conflict/i.test(pullRes)) {
      console.log(chalk.red('Pull failed or merge conflict! Resolve and try again.'));
      console.log(pullRes);
      return;
    }
    const pushRes = run('git push');
    if (/error|failed/i.test(pushRes)) {
      console.log(chalk.red('Push failed!'));
      console.log(pushRes);
      return;
    }
    console.log(boxen(chalk.green('All changes staged, committed, pulled, and pushed!'), { padding: 1, borderColor: 'green' }));
  } else {
    console.log(chalk.yellow('No changes to save.'));
  }

  // Also save in parent directory if it is a git repo and not the same as current
  const path = process.cwd();
  const pathModule = await import('path');
  const parent = pathModule.resolve(path, '..');
  if (parent !== path) {
    try {
      const fs = await import('fs');
      if (fs.existsSync(pathModule.join(parent, '.git'))) {
        console.log(chalk.cyan(`\nRunning save in parent repo: ${parent}`));
        const child_process = await import('child_process');
        const result = child_process.spawnSync(process.argv[0], [process.argv[1], 'save'], { cwd: parent, stdio: 'inherit' });
        if (result.error) {
          console.log(chalk.red('Failed to run save in parent repo:'), result.error);
        }
      }
    } catch (e) {
      console.log(chalk.red('Error checking or running save in parent repo:'), e);
    }
  }
}

async function main() {
  // Load plugins
  let pluginChoices = [];
  let plugins = [];
  let scriptChoices = [];
  let scripts = [];
  try {
    const fs = await import('fs');
    const pathModule = await import('path');
    // Plugins
    const pluginsDir = pathModule.join(process.cwd(), 'gitadox-plugins');
    if (fs.existsSync(pluginsDir)) {
      const files = fs.readdirSync(pluginsDir).filter(f => f.endsWith('.js'));
      for (const file of files) {
        try {
          const mod = await import(pathModule.join(pluginsDir, file));
          if (mod.name && mod.handler) {
            pluginChoices.push({ name: `[Plugin] ${mod.name}`, value: `plugin:${file}` });
            plugins.push({ file, ...mod });
          }
        } catch {}
      }
    }
    // Scripts
    const scriptsDir = pathModule.join(process.cwd(), 'scripts');
    if (fs.existsSync(scriptsDir)) {
      const files = fs.readdirSync(scriptsDir).filter(f => f.endsWith('.js'));
      for (const file of files) {
        try {
          const mod = await import(pathModule.join(scriptsDir, file));
          if (mod.name && mod.run) {
            scriptChoices.push({ name: `[Script] ${mod.name}`, value: `script:${file}` });
            scripts.push({ file, ...mod });
          }
        } catch {}
      }
    }
  } catch {}

  let choices = [
    { name: 'Save (add, commit, pull, push)', value: 'save' },
    { name: 'Undo Last Action', value: 'undo' },
    { name: 'Redo Last Action', value: 'redo' },
    { name: 'Status', value: 'status' },
    { name: 'Log', value: 'log' },
    { name: 'Branch', value: 'branch' },
    { name: 'Create Branch (AI-named)', value: 'ai-create-branch' },
    { name: 'Merge', value: 'merge' },
    { name: 'Stash', value: 'stash' },
    { name: 'Apply Stash', value: 'apply-stash' },
    { name: 'Drop Stash', value: 'drop-stash' },
    { name: 'List Stashes', value: 'list-stash' },
    { name: 'Advanced Commands', value: 'advanced' },
    { name: 'Check for Updates', value: 'check-updates' },
    { name: 'Initialize GitHub Repo', value: 'init-github' },
    { name: 'GitHub Integration', value: 'github' },
    { name: 'Explain Diff (AI)', value: 'explain-diff' },
    { name: 'Conflict Resolution (AI)', value: 'conflict-resolution' },
    { name: 'Natural Language Command (AI)', value: 'nl-command' },
    { name: 'Explain Command/Error (AI)', value: 'explain-anything' },
    { name: 'Push', value: 'push' },
    { name: 'Pull', value: 'pull' },
    ...pluginChoices,
    ...scriptChoices,
    { name: 'Help', value: 'help' },
    { name: 'Exit', value: 'exit' }
  ];
  // Stash support
  async function stash() {
    const res = run('git stash');
    console.log(res);
    // AI summary of stash
    const prompt = `Explain in plain English what just happened with this git stash command and what the user should know next.\n\nOUTPUT:\n${res}`;
    const aiRes = await fetch(OLLAMA_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
    });
    const text = await aiRes.text();
    let summary = '';
    for (const line of text.split(/\r?\n/)) {
      try {
        if (!line.trim()) continue;
        const obj = JSON.parse(line);
        if (obj.response) summary += obj.response;
      } catch {}
    }
    summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    if (summary) console.log('\nAI:', summary);
  }
  async function applyStash() {
    const res = run('git stash apply');
    console.log(res);
    // AI summary of unstash
    const prompt = `Explain in plain English what just happened with this git stash apply command and what the user should check for next.\n\nOUTPUT:\n${res}`;
    const aiRes = await fetch(OLLAMA_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
    });
    const text = await aiRes.text();
    let summary = '';
    for (const line of text.split(/\r?\n/)) {
      try {
        if (!line.trim()) continue;
        const obj = JSON.parse(line);
        if (obj.response) summary += obj.response;
      } catch {}
    }
    summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    if (summary) console.log('\nAI:', summary);
  }
  async function dropStash() {
    const res = run('git stash drop');
    console.log(res);
    // AI summary of drop stash
    const prompt = `Explain in plain English what just happened with this git stash drop command and what the user should know next.\n\nOUTPUT:\n${res}`;
    const aiRes = await fetch(OLLAMA_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
    });
    const text = await aiRes.text();
    let summary = '';
    for (const line of text.split(/\r?\n/)) {
      try {
        if (!line.trim()) continue;
        const obj = JSON.parse(line);
        if (obj.response) summary += obj.response;
      } catch {}
    }
    summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    if (summary) console.log('\nAI:', summary);
  }
  async function listStash() {
    const res = run('git stash list');
    console.log(res);
    // AI summary of list stash
    const prompt = `Explain in plain English what this git stash list output means and how to interpret the stashes.\n\nOUTPUT:\n${res}`;
    const aiRes = await fetch(OLLAMA_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
    });
    const text = await aiRes.text();
    let summary = '';
    for (const line of text.split(/\r?\n/)) {
      try {
        if (!line.trim()) continue;
        const obj = JSON.parse(line);
        if (obj.response) summary += obj.response;
      } catch {}
    }
    summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    if (summary) console.log('\nAI:', summary);
  }
  async function advancedCommands() {
    const advChoices = [
      { name: 'Checkout', value: 'checkout' },
      { name: 'Cherry-pick', value: 'cherry-pick' },
      { name: 'Rebase', value: 'rebase' },
      { name: 'Reset', value: 'reset' },
      { name: 'Tag', value: 'tag' },
      { name: 'Remote', value: 'remote' },
      { name: 'Diff', value: 'diff' },
      { name: 'Show', value: 'show' },
      { name: 'Revert', value: 'revert' },
      { name: 'Bisect', value: 'bisect' },
      { name: 'Blame', value: 'blame' },
      { name: 'Fetch', value: 'fetch' },
      { name: 'Config', value: 'config' },
      { name: 'Clean', value: 'clean' },
      { name: 'Archive', value: 'archive' },
      { name: 'Describe', value: 'describe' },
      { name: 'Reflog', value: 'reflog' },
      { name: 'Shortlog', value: 'shortlog' },
      { name: 'Notes', value: 'notes' },
      { name: 'Grep', value: 'grep' },
      { name: 'Submodule', value: 'submodule' },
      { name: 'Worktree', value: 'worktree' },
      { name: 'Cancel', value: 'cancel' }
    ];
    const { adv } = await inquirer.prompt([
      {
        type: 'list',
        name: 'adv',
        message: 'Advanced Git Command:',
        choices: advChoices
      }
    ]);
    if (adv === 'cancel') return;

    // Prompt map for each command
    const prompts = {
      'checkout': 'Enter branch or commit to checkout:',
      'cherry-pick': 'Enter commit hash to cherry-pick:',
      'rebase': 'Enter branch to rebase onto:',
      'reset': 'Enter commit or mode (e.g., --hard HEAD~1):',
      'tag': 'Enter tag name (and optionally commit):',
      'remote': 'Enter remote command (add, remove, set-url, etc.):',
      'diff': 'Enter diff arguments (e.g., file, branch):',
      'show': 'Enter object (commit, tag, etc.) to show:',
      'revert': 'Enter commit hash to revert:',
      'bisect': 'Enter bisect command (start, good, bad, reset):',
      'blame': 'Enter file to blame:',
      'fetch': 'Enter remote (or leave blank for default):',
      'config': 'Enter config key (and value if setting):',
      'clean': 'Enter clean options (e.g., -fd):',
      'archive': 'Enter archive options:',
      'describe': 'Enter describe options:',
      'reflog': 'Enter reflog options:',
      'shortlog': 'Enter shortlog options:',
      'notes': 'Enter notes command:',
      'grep': 'Enter pattern to grep:',
      'submodule': 'Enter submodule command:',
      'worktree': 'Enter worktree command:'
    };

    let arg = '';
    if (adv !== 'fetch' && adv !== 'cancel') {
      arg = (await inquirer.prompt([{ type: 'input', name: 'arg', message: prompts[adv] || 'Enter argument:' }])).arg;
    } else if (adv === 'fetch') {
      arg = (await inquirer.prompt([{ type: 'input', name: 'arg', message: prompts[adv] }])).arg;
    }
    const cmd = `git ${adv}${arg ? ' ' + arg : ''}`;
    const res = run(cmd);
    console.log(res);
    // AI explanation
    const aiPrompt = `Explain in plain English what this git ${adv} command did and what the output means.\n\nCOMMAND: ${cmd}\nOUTPUT:\n${res}`;
    const aiRes = await fetch(OLLAMA_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ model: OLLAMA_MODEL, prompt: aiPrompt })
    });
    const text = await aiRes.text();
    let summary = '';
    for (const line of text.split(/\r?\n/)) {
      try {
        if (!line.trim()) continue;
        const obj = JSON.parse(line);
        if (obj.response) summary += obj.response;
      } catch {}
    }
    summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
    if (summary) console.log('\nAI:', summary);
  }
  // Remove duplicates and empty entries
  const seen = new Set();
  choices = choices.filter(c => {
    if (!c || !c.value || seen.has(c.value)) return false;
    seen.add(c.value);
    return true;
  });
  const { cmd } = await inquirer.prompt([
    {
      type: 'no-wrap-list',
      name: 'cmd',
      message: chalk.cyan('What do you want to do?'),
      choices,
      pageSize: 10
    }
  ]);
  if (cmd === 'github') {
    await githubMenu();
    return main();
  }
  if (cmd === 'check-updates') {
    await checkForUpdates();
    return main();
  }
  async function checkForUpdates() {
    const fs = await import('fs');
    const pathModule = await import('path');
    const pkgPath = pathModule.join(process.cwd(), 'package.json');
    let currentVersion = null;
    if (fs.existsSync(pkgPath)) {
      try {
        const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
        currentVersion = pkg.version;
      } catch {}
    }
    if (!currentVersion) {
      console.log(chalk.red('Could not determine current version.'));
      return;
    }
    console.log(chalk.cyan('Checking for updates on npm...'));
    try {
      const latest = run('npm view gitadox version');
      if (latest && latest !== currentVersion) {
        console.log(boxen(chalk.yellow(`Update available! Current: ${currentVersion}, Latest: ${latest}\nRun: npm install -g gitadox`), {padding: 1, borderColor: 'yellow'}));
      } else {
        console.log(boxen(chalk.green('You are using the latest version.'), {padding: 1, borderColor: 'green'}));
      }
    } catch (e) {
      console.log(chalk.red('Failed to check for updates.'), e.message);
    }
  }
  // ...existing code...
  // ...existing code...
  if (cmd === 'init-github') {
    await initGitHubRepo();
    return main();
  }
  async function initGitHubRepo() {
    const { token } = await inquirer.prompt([
      {
        type: 'password',
        name: 'token',
        message: 'Enter your GitHub Personal Access Token:',
        mask: '*'
      }
    ]);
    const { user, repo, visibility } = await inquirer.prompt([
      {
        type: 'input',
        name: 'user',
        message: 'GitHub username or org:',
        default: 'theKennethy'
      },
      {
        type: 'input',
        name: 'repo',
        message: 'Repository name:',
        default: 'cli'
      },
      {
        type: 'list',
        name: 'visibility',
        message: 'Repository visibility:',
        choices: [
          { name: 'Public', value: false },
          { name: 'Private', value: true }
        ],
        default: false
      }
    ]);
    // Create repo via GitHub API
    let created = false;
    try {
      const res = await fetch(`https://api.github.com/user/repos`, {
        method: 'POST',
        headers: {
          Authorization: `token ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ name: repo, private: visibility })
      });
      if (res.status === 201) {
        console.log(chalk.green('GitHub repository created successfully!'));
        created = true;
      } else {
        const err = await res.json();
        if (err && err.message && err.message.includes('name already exists')) {
          console.log(chalk.yellow('Repository already exists on GitHub. Proceeding...'));
          created = true;
        } else {
          console.log(chalk.red('Failed to create repository:'), err.message || res.statusText);
          return;
        }
      }
    } catch (e) {
      console.log(chalk.red('Error creating repository on GitHub:'), e.message);
      return;
    }
    const remote = `https://github.com/${user}/${repo}.git`;
    try {
      console.log(chalk.cyan(`Adding remote: ${remote}`));
      run(`git remote add origin "${remote}"`);
    } catch (e) {
      console.log(chalk.yellow('Remote may already exist. Skipping.'));
    }
    console.log(chalk.cyan('Renaming branch to main...'));
    run('git branch -M main');
    console.log(chalk.cyan('Pushing to origin main...'));
    run('git push -u origin main');
    console.log(boxen(chalk.green(`GitHub repo (${user}/${repo}) initialized and pushed!`), {padding: 1, borderColor: 'green'}));
  }
  async function githubMenu() {
    const { token } = await inquirer.prompt([
      {
        type: 'password',
        name: 'token',
        message: 'Enter your GitHub Personal Access Token:',
        mask: '*'
      }
    ]);
    let user;
    try {
      user = await github.getUser(token);
    } catch (e) {
      console.log(chalk.red('GitHub authentication failed.'));
      return;
    }
    const { owner, repo } = await getRepoInfo();
    const { ghAction } = await inquirer.prompt([
      {
        type: 'list',
        name: 'ghAction',
        message: 'GitHub Actions:',
        choices: [
          { name: 'List Pull Requests', value: 'listPRs' },
          { name: 'Create Pull Request', value: 'createPR' },
          { name: 'List Issues', value: 'listIssues' },
          { name: 'Create Issue', value: 'createIssue' },
          { name: 'Back', value: 'back' }
        ]
      }
    ]);
    if (ghAction === 'listPRs') {
      const prs = await github.listPullRequests(owner, repo, token);
      if (!prs.length) return console.log(chalk.yellow('No pull requests found.'));
      prs.forEach(pr => {
        console.log(boxen(`#${pr.number}: ${pr.title}\n${pr.html_url}`, {padding: 1, borderColor: 'blue'}));
      });
    } else if (ghAction === 'createPR') {
      const { title, head, base } = await inquirer.prompt([
        { type: 'input', name: 'title', message: 'PR title:' },
        { type: 'input', name: 'head', message: 'Source branch (head):' },
        { type: 'input', name: 'base', message: 'Target branch (base):' }
      ]);
      const pr = await github.createPullRequest(owner, repo, title, head, base, token);
      console.log(boxen(`Created PR #${pr.number}: ${pr.title}\n${pr.html_url}`, {padding: 1, borderColor: 'green'}));
    } else if (ghAction === 'listIssues') {
      const issues = await github.listIssues(owner, repo, token);
      if (!issues.length) return console.log(chalk.yellow('No issues found.'));
      issues.forEach(issue => {
        console.log(boxen(`#${issue.number}: ${issue.title}\n${issue.html_url}`, {padding: 1, borderColor: 'magenta'}));
      });
    } else if (ghAction === 'createIssue') {
      const { title, body } = await inquirer.prompt([
        { type: 'input', name: 'title', message: 'Issue title:' },
        { type: 'input', name: 'body', message: 'Issue body:' }
      ]);
      const issue = await github.createIssue(owner, repo, title, body, token);
      console.log(boxen(`Created Issue #${issue.number}: ${issue.title}\n${issue.html_url}`, {padding: 1, borderColor: 'green'}));
    }
  }

  async function getRepoInfo() {
    // Try to get owner/repo from git remote
    const remote = run('git remote get-url origin');
    const m = remote.match(/github.com[:/](.+?)\/(.+?)(\.git)?$/);
    if (m) {
      return { owner: m[1], repo: m[2].replace(/\.git$/, '') };
    }
    return await inquirer.prompt([
      { type: 'input', name: 'owner', message: 'GitHub owner/user:' },
      { type: 'input', name: 'repo', message: 'GitHub repo:' }
    ]);
  }
  if (cmd === 'save') {
    await save();
  } else if (cmd === 'undo') {
    await undoLastAction();
  } else if (cmd === 'redo') {
    await redoLastAction();
  } else if (cmd === 'status') {
    await aiStatus();
  } else if (cmd === 'log') {
    await aiLog();
  } else if (cmd === 'branch') {
    await aiBranch();
  } else if (cmd === 'ai-create-branch') {
    await aiCreateBranch();
  } else if (cmd === 'merge') {
    await aiMerge();
  } else if (cmd === 'stash') {
    await stash();
  } else if (cmd === 'apply-stash') {
    await applyStash();
  } else if (cmd === 'drop-stash') {
    await dropStash();
  } else if (cmd === 'list-stash') {
    await listStash();
  } else if (cmd === 'advanced') {
    await advancedCommands();
  } else if (cmd === 'explain-diff') {
    await aiExplainDiff();
  } else if (cmd === 'conflict-resolution') {
    await aiConflictResolution();
  } else if (cmd === 'nl-command') {
    await aiNaturalLanguageCommand();
  } else if (cmd === 'explain-anything') {
    await aiExplainAnything();
  } else if (cmd === 'push') {
    await aiPush();
  } else if (cmd === 'pull') {
    await aiPull();
  } else if (cmd && cmd.startsWith('plugin:')) {
    const file = cmd.replace('plugin:', '');
    const plugin = plugins.find(p => p.file === file);
    if (plugin) await plugin.handler();
  } else if (cmd && cmd.startsWith('script:')) {
    const file = cmd.replace('script:', '');
    const script = scripts.find(s => s.file === file);
    if (script) await script.run();
  } else if (cmd === 'help') {
    await help();
  } else if (cmd === 'exit') {
    process.exit(0);
  }
  process.exit(0);
}

if (process.argv[2] === 'save') {
  await save();
} else {
  await main();
}
