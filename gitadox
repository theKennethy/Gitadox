#!/usr/bin/env node

// Undo/Redo state
let lastAction = null;
let redoAction = null;

async function undoLastAction() {
  if (!lastAction) {
    console.log('Nothing to undo.');
    return;
  }
  if (lastAction.type === 'commit') {
    // Undo last commit (soft reset)
    run('git reset --soft HEAD~1');
    console.log('Last commit undone.');
    redoAction = lastAction;
    lastAction = null;
  } else if (lastAction.type === 'branch-switch') {
    // Switch back to previous branch
    run(`git checkout ${lastAction.prevBranch}`);
    console.log(`Switched back to branch: ${lastAction.prevBranch}`);
    redoAction = lastAction;
    lastAction = null;
  } else {
    console.log('Nothing to undo.');
  }
}

async function redoLastAction() {
  if (!redoAction) {
    console.log('Nothing to redo.');
    return;
  }
  if (redoAction.type === 'commit') {
    // Redo commit (not possible to fully restore, so just notify)
    console.log('Redo for commit is not supported. Please recommit manually.');
    redoAction = null;
  } else if (redoAction.type === 'branch-switch') {
    // Switch again to the branch
    run(`git checkout ${redoAction.newBranch}`);
    console.log(`Switched again to branch: ${redoAction.newBranch}`);
    redoAction = null;
  } else {
    console.log('Nothing to redo.');
  }
}
async function aiExplainAnything() {
  const { explainInput } = await inquirer.prompt([
    { type: 'input', name: 'explainInput', message: chalk.cyan('Paste a git command or error to explain:') }
  ]);
  if (!explainInput || !explainInput.trim()) {
    console.log(chalk.yellow('No input provided.'));
    return;
  }
  const prompt = `You are an expert git assistant. Explain the following git command or error message in clear, plain English, and provide actionable advice if relevant.\n\nINPUT:\n${explainInput}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let answer = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) answer += obj.response;
    } catch {}
  }
  answer = answer.replace(/\n{2,}/g, '\n').trim();
  console.log(boxen(chalk.cyan('AI Explanation:'), {padding: 1, borderColor: 'cyan'}));
  console.log(answer);
}
async function aiNaturalLanguageCommand() {
  const { nlcmd } = await inquirer.prompt([
    { type: 'input', name: 'nlcmd', message: chalk.cyan('Describe what you want to do (in plain English):') }
  ]);
  if (!nlcmd || !nlcmd.trim()) {
    console.log(chalk.yellow('No command entered.'));
    return;
  }
  const prompt = `You are an expert git CLI assistant. The user typed: "${nlcmd}".\n\n1. Suggest the exact git command(s) to accomplish this.\n2. Briefly explain what each command does.\n3. If the request is ambiguous, ask for clarification.\n\nFormat:\nCOMMAND: <git command>\nEXPLANATION: <explanation>\n`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let answer = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) answer += obj.response;
    } catch {}
  }
  answer = answer.replace(/\n{2,}/g, '\n').trim();
  console.log(boxen(chalk.cyan('AI Command Suggestion:'), {padding: 1, borderColor: 'cyan'}));
  console.log(answer);
}
async function aiConflictResolution() {
  // Check for merge conflicts
  const status = run('git status');
  if (!/Unmerged paths|both modified|You have unmerged paths|fix conflicts/i.test(status)) {
    console.log(chalk.green('No merge conflicts detected.'));
    return;
  }
  // Get the diff of conflicts
  const diff = run('git diff');
  if (!diff) {
    console.log(chalk.yellow('No diff available for conflicts.'));
    return;
  }
  const prompt = `The following git status and diff indicate a merge conflict. Suggest step-by-step instructions to resolve the conflict, and summarize what the conflict is about.\n\nGIT STATUS:\n${status}\n\nGIT DIFF:\n${diff}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  console.log(boxen(chalk.cyan('AI Conflict Resolution Suggestion:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary);
}
async function aiExplainDiff() {
  const diff = run('git diff');
  if (!diff) {
    console.log(chalk.yellow('No changes to explain.'));
    return;
  }
  const prompt = `Explain the following git diff in plain English for a developer. Summarize what was changed, which files were affected, and the overall impact.\n${diff}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  console.log(boxen(chalk.cyan('AI Diff Explanation:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || diff);
}


async function aiCreateBranch() {
  // Get current status or context for branch naming
  const status = run('git status');
  const prompt = `Suggest a short, valid git branch name (kebab-case, no spaces or special characters) based on this git status/context. Only output the branch name, nothing else.\n${status}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let branchName = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) branchName += obj.response;
    } catch {}
  }
  branchName = branchName.replace(/[^a-zA-Z0-9\-]/g, '').replace(/\s+/g, '-').toLowerCase().trim();
  if (!branchName) {
    console.log(chalk.red('AI did not provide a valid branch name.'));
    return;
  }
  // Show the suggested branch name and create/switch to it
  console.log(boxen(chalk.green(`AI suggested branch name: ${branchName}`), { padding: 1, borderColor: 'green' }));
  const result = run(`git checkout -b ${branchName}`);
  console.log(boxen(chalk.green(`Created and switched to new branch: ${branchName}`), { padding: 1, borderColor: 'green' }));
  console.log(result);
}

// Usage: ./gitadox or node gitadox
import inquirer from 'inquirer';
import path from 'path';
// Register custom no-wrap list prompt
const NoWrapListPromptModule = await import('./noWrapListPrompt.js');
const NoWrapListPrompt = NoWrapListPromptModule.default || NoWrapListPromptModule;
inquirer.registerPrompt('no-wrap-list', NoWrapListPrompt);
import chalk from 'chalk';
import boxen from 'boxen';
import fetch from 'node-fetch';
import { execSync, exec } from 'child_process';

const OLLAMA_URL = 'http://localhost:11434/api/generate';
const OLLAMA_MODEL = 'llama3.1:8b';

function run(cmd, opts = {}) {
  try {
    return execSync(cmd, { stdio: 'pipe', encoding: 'utf8', ...opts }).trim();
  } catch (e) {
    return e.stdout ? e.stdout.toString() : e.message;
  }
}

async function getAICommitMessage(diff) {
  const prompt = `Analyze the following git diff and generate a meaningful, context-aware commit message that accurately summarizes the changes. The message must follow the Conventional Commits specification (e.g., feat:, fix:, chore:, refactor:, etc.), and should be clear and specific about what was changed. Only output the commit message itself, no explanations or formatting.\n\n${diff}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  // Ollama streams JSON lines, each with a 'response' field. Extract and join them.
  let commitMsg = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) commitMsg += obj.response;
    } catch {}
  }
  // Clean up and return the message
  commitMsg = commitMsg.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  // Optionally, only take the first line for a concise commit
  if (commitMsg.includes('.')) commitMsg = commitMsg.split('.')[0].trim();
  return commitMsg || 'chore: update';
}

async function aiStatus() {
  const status = run('git status');
  const prompt = `Summarize this git status output in plain English for a developer:\n${status}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  console.log(boxen(chalk.cyan('AI Status Summary:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || status);
}

async function aiLog() {
  const log = run('git log --oneline --decorate --graph -20');
  const prompt = `Summarize this git log for a developer, highlighting key changes and branches. Format the summary in clear, short paragraphs or bullet points for easy reading.\n${log}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  // Try to preserve line breaks and bullet points for readability
  summary = summary.replace(/\n{2,}/g, '\n').replace(/\n/g, '\n').replace(/\s+\n/g, '\n').trim();
  console.log(boxen(chalk.cyan('AI Log Summary:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || log);
}

async function aiBranch() {
  const branchesRaw = run('git branch -a');
  // Collect all branches, local and remote, and remove duplicates
  let branches = branchesRaw
    .split('\n')
    .map(b => b.replace('*', '').trim())
    .filter(b => b && !b.includes('->'));
  // Remove duplicate remote branches that match local ones
  const uniqueBranches = Array.from(new Set(branches));
  const { branch } = await inquirer.prompt([
    {
      type: 'list',
      name: 'branch',
      message: chalk.cyan('Select a branch to switch to:'),
      choices: uniqueBranches,
      pageSize: 15
    }
  ]);
  // Track undo for branch switch
  const currentBranch = run('git rev-parse --abbrev-ref HEAD');
  const result = run(`git checkout ${branch}`);
  lastAction = { type: 'branch-switch', prevBranch: currentBranch, newBranch: branch };
  redoAction = null;
  console.log(boxen(chalk.green(`Switched to branch: ${branch}`), { padding: 1, borderColor: 'green' }));
  console.log(result);
}

async function aiMerge() {
  const { branch } = await inquirer.prompt([
    { type: 'input', name: 'branch', message: 'Enter the branch to merge into current:' }
  ]);
  const mergeRes = run(`git merge ${branch}`);
  const prompt = `Explain the result of this git merge command for a developer:\n${mergeRes}`;
  const res = await fetch(OLLAMA_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model: OLLAMA_MODEL, prompt })
  });
  const text = await res.text();
  let summary = '';
  for (const line of text.split(/\r?\n/)) {
    try {
      if (!line.trim()) continue;
      const obj = JSON.parse(line);
      if (obj.response) summary += obj.response;
    } catch {}
  }
  summary = summary.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  console.log(boxen(chalk.cyan('AI Merge Summary:'), {padding: 1, borderColor: 'cyan'}));
  console.log(summary || mergeRes);
}

async function aiPush() {
  const pushRes = run('git push');
  console.log(pushRes);
}

async function aiPull() {
  const pullRes = run('git pull');
  console.log(pullRes);
}

async function help() {
  const helpText = `Commands available:\n\n- Save (add, commit, pull, push): Stage, commit, pull, and push changes with AI commit message\n- Status: Show git status\n- Log: Show git log\n- Branch: List branches\n- Create Branch (AI-named): Create a new branch with an AI-generated name\n- Merge: Merge branches\n- Push: git push\n- Pull: git pull\n- Help: Show this help\n- Exit: Exit the CLI`;
  console.log(boxen(chalk.cyan('Help'), {padding: 1, borderColor: 'cyan'}));
  console.log(helpText);
}

async function save() {
  // Always stage all changes (including unstaged and deletions)
  run('git add -A');
  run('git add gitadox/gitadox');
  const status = run('git status --porcelain');
  if (status) {
    const diff = run('git diff --cached');
    const commitMsg = await getAICommitMessage(diff);
    run(`git commit -m "${commitMsg.replace(/"/g, '\"')}"`);
    // Track undo for commit
    lastAction = { type: 'commit' };
    redoAction = null;
    const pullRes = run('git pull --rebase');
    if (/error|conflict/i.test(pullRes)) {
      console.log(chalk.red('Pull failed or merge conflict! Resolve and try again.'));
      console.log(pullRes);
      return;
    }
    const pushRes = run('git push');
    if (/error|failed/i.test(pushRes)) {
      console.log(chalk.red('Push failed!'));
      console.log(pushRes);
      return;
    }
    console.log(boxen(chalk.green('All changes staged, committed, pulled, and pushed!'), { padding: 1, borderColor: 'green' }));
  } else {
    console.log(chalk.yellow('No changes to save.'));
  }

  // Also save in parent directory if it is a git repo and not the same as current
  const path = process.cwd();
  const pathModule = await import('path');
  const parent = pathModule.resolve(path, '..');
  if (parent !== path) {
    try {
      const fs = await import('fs');
      if (fs.existsSync(pathModule.join(parent, '.git'))) {
        console.log(chalk.cyan(`\nRunning save in parent repo: ${parent}`));
        const child_process = await import('child_process');
        const result = child_process.spawnSync(process.argv[0], [process.argv[1], 'save'], { cwd: parent, stdio: 'inherit' });
        if (result.error) {
          console.log(chalk.red('Failed to run save in parent repo:'), result.error);
        }
      }
    } catch (e) {
      console.log(chalk.red('Error checking or running save in parent repo:'), e);
    }
  }
}

async function main() {
  let choices = [
    { name: 'Save (add, commit, pull, push)', value: 'save' },
    { name: 'Undo Last Action', value: 'undo' },
    { name: 'Redo Last Action', value: 'redo' },
    { name: 'Status', value: 'status' },
    { name: 'Log', value: 'log' },
    { name: 'Branch', value: 'branch' },
    { name: 'Create Branch (AI-named)', value: 'ai-create-branch' },
    { name: 'Merge', value: 'merge' },
    { name: 'Explain Diff (AI)', value: 'explain-diff' },
    { name: 'Conflict Resolution (AI)', value: 'conflict-resolution' },
    { name: 'Natural Language Command (AI)', value: 'nl-command' },
    { name: 'Explain Command/Error (AI)', value: 'explain-anything' },
    { name: 'Push', value: 'push' },
    { name: 'Pull', value: 'pull' },
    { name: 'Help', value: 'help' },
    { name: 'Exit', value: 'exit' }
  ];
  // Remove duplicates and empty entries
  const seen = new Set();
  choices = choices.filter(c => {
    if (!c || !c.value || seen.has(c.value)) return false;
    seen.add(c.value);
    return true;
  });
  const { cmd } = await inquirer.prompt([
    {
      type: 'no-wrap-list',
      name: 'cmd',
      message: chalk.cyan('What do you want to do?'),
      choices,
      pageSize: 10
    }
  ]);
  if (cmd === 'save') {
    await save();
  } else if (cmd === 'undo') {
    await undoLastAction();
  } else if (cmd === 'redo') {
    await redoLastAction();
  } else if (cmd === 'status') {
    await aiStatus();
  } else if (cmd === 'log') {
    await aiLog();
  } else if (cmd === 'branch') {
    await aiBranch();
  } else if (cmd === 'ai-create-branch') {
    await aiCreateBranch();
  } else if (cmd === 'merge') {
    await aiMerge();
  } else if (cmd === 'explain-diff') {
    await aiExplainDiff();
  } else if (cmd === 'conflict-resolution') {
    await aiConflictResolution();
  } else if (cmd === 'nl-command') {
    await aiNaturalLanguageCommand();
  } else if (cmd === 'explain-anything') {
    await aiExplainAnything();
  } else if (cmd === 'push') {
    await aiPush();
  } else if (cmd === 'pull') {
    await aiPull();
  } else if (cmd === 'help') {
    await help();
  } else if (cmd === 'exit') {
    process.exit(0);
  }
  process.exit(0);
}

if (process.argv[2] === 'save') {
  await save();
} else {
  await main();
}
